# 10. 객체지향 쿼리 언어

## 10.1 객체지향 쿼리 조회
  - JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원 한다.
    - 모든 회원의 엔티티를 메모리에 올려두고 검색 할 수는 없지 않은가?
    - ORM을 사용하면 Table이 아닌 Entity를 대상으로 개발하므로 검색도 Table이 아닌 Entity를 대상으로 필요하다.
  - Criteria, QueryDSL -> JPQL을 편하게 사용하게 해주는것, JPQL이 젤 중요하다.

### JPQL
  - JPQL은 Entity를 조회하는 객체지향 쿼리다
  - SQL을 추상화해서 특정 DB에 의존하지 않는다. (dialect는 있음)
  - SQL 보다 간결하다(엔티티 직접 조회, 묵시적 조인, 다형성 지원..)
```java
@Entity(name="Member")
public class Member {
  @Column(name = "name")
  private String name;
  //..
}

String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```

### Criteria
  - JPQL을 생성하는 빌더 클래스 -> 문자가 아닌 코드로 JPQL을 작성 할 수있다.
  - 컴파일 시점에 오류 발견 가능, 자동 완성 지원(feat.IDE), 동적 쿼리를 작성하기 좋다
  - 그러나 복잡하고 장황하다. 사용하기 불편함.

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 조회를 시작할 클래스
Root<Member> m = query.from(Member.class);

CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
//with meta model
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get(Member_.username), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```

### QueryDSL
- 코드 기반, 단순하고 쉽다
- JPA 표준아님, [오픈소스 프로젝트](https://github.com/querydsl/querydsl)
- Spring Data project가 지원한다.
```java
JPAQuery query = new JPAQuery(em);
QMember member = Qmember.member; // Query 전용 class

List<Member> members =
  query.from(member)
  .where(member.username.eq("kim"))
  .list(member);

```

### Native SQL
 - 특정 DB에 의존하는 기능을 사용해야 할 때(e.g CONNECT BY)
 - SQL hint, JPQL이 지원하지 않는 기능

### JDBC 직접 사용
  - JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않음. JPA 구현체가 제공하는 방법을 사용해야 한다.
  - JDBC나 Mybatis를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 flush 해야한다.
    - JDBC나 MyBatis 같은 SQL Mapper는 JPA를 우회해서 DB에 접근하기때문, 데이터의 무결성이 깨질 수 있다. (p.353)
    - JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 flush해서 DB와 영속성 컨텍스트를 동기화 하면된다.
    - Spring은 이 둘을 손쉽게 통합 해주는 기능을 제공한다.

## JPQL
  - SQL과 비슷한 SELECT, UPDATE, DELETE를 사용 가능
  - Entity를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 INSERT는 없다.
  ### SELECT
  ```sql
  SELECT m from Member AS m where m.userame='Hello'

  ```
  - 대소문자 구분(Member, username)
  - Entity 이름을 사용한다 클래스 명이 아님 `@Entity(name="XXX")` Entity 이름을 정의하지 않으면 클래스 명을 기본값으로 사용한다.
  - 별칭(As,식별변수) 필수
    - JPQL은 별칭이 필수이다  (As는 생략 가능 ex. Member as m)
    ```sql
      // 잘못된 문법, username을 m.username으로 고쳐야 한다.
      SELECT username from Member m 
    ```
  
  - TypedQuery, Query
    - 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery, 아니라면 query 객체를 사용하면 된다.
      ```sql
        // 조회 대상이 명확 함
        TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", member.calss)

        // 조회 대상이 명확하지 않음
        Query query = em.createQuery("SELECT m.username, m.age from Member m")
        fofreach(Object o : query.getResultList()){
          object[] result = (object[]) o; // 결과가 둘이 이상이면 object[] 반환
        }
      ```

## 파라메터 바인딩
  - JDBC는 위치 기준 파라메터 바인딩만 지원하지만, JPQL은 기준 파라메터 바인딩도 지원한다.
    ```java
    //위치 기준
    List<Member> members = em.createQuery(
        "SELECT m from Member m where m.username = ?1",
        Member.class)
        .setParameter(1, "User1")
        .getResultList();

    //이름 기준
      List<Member> members = em.createQuery(
        "SELECT m from Member m where m.username = :username",
        Member.class)
        .setParameter("username", "User1")
        .getResultList();
    ```
  - 이름 기준 파타메터 바인딩을 사용하는 것이 더 명확하다.
  - 위치 기준 파라메터 바인딩은 SQL injection에 취약함
  - 파라메터 바인딩을 사용하면 파라메터가 달라도 같은 쿼리로 인식해서 JPA는 JPQL을 SQL로 파싱한 결과를 재사용 할 수있다. 필수다.

## 프로젝션
  - SELECT 절에 조회할 대상을 지정하는것을 프로젝션 이라고 한다.
  
### Entity 프로젝션
```sql
  SELECT m from Member m
  SELECT m.team from Member m
```
- 원하는 객체를 바로 조회 할 수 있음
- 이렇게 조회한 Entity는 영속성 컨텍스트에서 관리한다.

### EmbedType 프로젝션
```java
String query = "SELECT a from Address a";
List<Address> addresses = em.createQuery(query, Address.class).getResultList();
```
- Embeded 타입은 Entity가 아닌 값 타입이다. 이렇게 직접 조회한 embeded 타입은 영속성 컨텍스트에서 관리 되지 않는다.

### 스칼라 타입 프로젝션
- 숫자, 문자, 날짜 와 같은 기본 데이터들을 스칼라 타입이라고 함.
```java
List<String> usernames =
  em.createQuery("SELECT username from Member m", String.class).getResultList();
```

### 여러 값 조회
- 꼭 필요한 데이터만 선택해서 조회 해야 할 때 사용
- TypedQuery를 사용할 수 없고, Query를 사용해야함
```java
List<Object[]> resultList = 
  em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o").getResultList();

for (Object[] row : resultList){
  Member member = (Member) row[0]; //entity
  Product product = (Product) row[1] // Entity
  int OrderAmount = (Interger) row[2] //scala
 }
```
- 이떄도 조회한 엔티티는 영속성 컨텍스트에서 관리한다.

### New 명령어
- 여러 필드를 프로젝션 하면 타입을 지정할 수 없으므로 TypedQuery를 사용할 수 없다.
- 여러 필드에 대한 타입을 지정해서 의미 있는 객채로 변환 하여 쓸 수 있다.
```java
TypedQuery<UserDTO> query = 
  em.createQuery(
    "SELECT new jpabook.sql.UserDTO(m.username, m.age) from Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```
- New 명령어를 사용하면 반환받을 클래스를 지정 할 수있다. 이 클래스의 생성자에 JPQL 조회 결과를 넘겨 줄수 있다.
- 패키지 명을 포함한 전체 클래스 명을 입력해야함.
- 순서와 타입이 일치하는 생성자가 필요함.
- new를 사용한 클래스로 TypedQuery를 사용할 수 있어서, 객체변환 작업을 줄일 수 있다.

### 페이징 API
```java
TypedQuery<Member> query =
  em.createQuery("SELECT m from Member m OREDER BY m.username DESC", Member.class);

query.setFirstResult(10); // offset
query.setMaxResults(20); // limit
query.getResultList();
```
- DB 마다 문법이 다름, 연결된 DB에 따라 다른 SQL이 날라간다.


