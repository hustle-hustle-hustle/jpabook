# 고급 매핑

## 이 장의 목표

- 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지
- 엔티티에서 공통으로 사용되는 매핑정보를 어떻게 사용하는지
- 조인테이블(연결 테이블, 관계 테이블) 조인 방법
- 엔티티 하나에 여러 테이블 매핑

## 상속 관계 매핑

데이터베이스는 상속 개념이 없다. 따라서 슈퍼타입 서브타입 관계라는 모델링 기법이 상속과 유사하므로 이용된다. 가령 앨범,영화,책이라는 논리 모델이 있고 있고 공통된 데이터를 관리하기 위해 물품이라는 논리 모델이 있을 수 있다.

이러한 논리모델을 실제 물리 테이블로 구현하는 방법은 3가지

1. 각 논리모델을 테이블로 변환 후 조인한다.
2. 테이블을 하나만 사용해서 통합한다. JPA 에서는 단일 테이블 전략이라 한다.
3. 서브타입 테이블로 변환

### 1. 조인 전략


```
// 256p
@Entity
@Inheritance(strategy=InheritanceType.JOINED)
```

#### 장점
- 테이블 정규화
- 외래키 참조 무결성 제약 활용
- 저장공간 효율화

#### 단점
- 조인으로 인한 성능 저화
- 등록시 INSERT 2번 실행
- 조회쿼리가 복잡

### 2.단일 테이블

```
/// 248
```

#### 장점
- 조인 필요 없이 빠른 조회

#### 단점
- 자식 엔티티가 매핑한 컬럼은 null 허용
- 단일 테이블에 모든 것을 저장하므로 테이블이 커진다.


### 3.구현 클래스마다 테이블 (Table-per-Concrete Strategy)

#### 장점
- 서브타입 구분하여(각각) 처리할 때 효과적
- not null 조건 사용가능

#### 단점
- 여러 자식 테이블을 '함께' 조회할 때 느리다. (SQL UNION 사용)
- 자식테이블 통합하여 쿼리가 힘듬

=> 데이터베이스 설계자 및 ORM 전문가 둘다 추천하지 않음. 조인이나 단일 테이블 전략을 고려하자

## @MappedSuperclass

추상클래스 처럼, 엔티티에 실제로 매핑되지는 않고 매핑 정보를 상속할 목적이 있을 때 사용. => created_at, updated_at 같이 공통적으로 반복사용되는 컬럼을 만들면 좋을 것 같다.

## 복합 키와 식별 관계 매핑

### 식별 관계 / 비식별 관계

- 식별관계: 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본키 + 외래키로 사용하는 관계
- 비식별관계: 부모테이블의 기본 키를 내려받아 외래키로만 사용하는 관계

### 복합키

@IdClass 와 @EmbeddedId 로 구현가능하다. 전자는 데이터베이스에 가까운 방법이고 후자는 객체지향 스러운 방법

### 복합키: 비식별 관계
```
// p 257
```

### 복합키: 식별 관계
-> TMI, skip. 복합키 + 식별관계는 바람직하지도 않고, 실제 이렇게 모델링 하는 경우도 드물다. 생략하자.

### 비식별 관계 예시
가장 일반적인 형태. 복합키 클래스를 만들지 않아도 됨 => 단순
```
// p 266 
```

### 식별관계보다는 비식별관계를 쓰자.
- 식별관계는 부모 테이블의 키가 자식으로 전파되고, 자식의 깊이가 깊어질 수록 키관리가 복잡해진다.
- 식별 관계를 사용하면 기본키가 의미있는 자연키 컬럼을 조합하는데, 의미는 언젠간 변한다. 비식별관계의 대리키(생성한 키, Auto Increment) 를 사용하자.

## 조인 테이블
```예시 쭉```

## 엔티티 하나에 여러 테이블 매핑
```예시 쭉```
